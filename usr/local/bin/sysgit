#!/bin/bash

# Default config
GIT=/usr/bin/git
SYSGIT_DIR=/var/lib/sysgit
ALWAYS_ROOT=0
INSTALL_PREFIX=/usr/local
INSTALL_SYSCONFDIR=/etc
UPDATE_REPO=https://framagit.org/kepon/sysgit.git
UPDATE_BRANCH=master
MULTI_GIT_COMMITTER=0
MULTI_GIT_COMMITTER_PROFILE=/var/lib/sysgit/sysgit.profile
MULTI_GIT_COMMITTER_PROFILE_HISTORY=/var/lib/sysgit/sysgit.profile.history
LOGOUT_CHECK=0

# Load config file
CONFIG=/etc/sysgit.conf

usage() {
  cat <<'EOF'
Usage: sysgit [-apt] [-c <config>] [-p <profil>] [-u] [-h] [init|git-args...]
  -apt         Commit automatique pour les hooks APT
  -c <config>  Chemin vers le fichier de configuration
  -p <profil>  Profil de commiteur (nom ou index)
  -u           Mettre a jour depuis le depot officiel et reinstaller
  -h           Afficher cette aide
EOF
}

APT_MODE=0
if [ "${1}" = "-apt" ]; then
  APT_MODE=1
  shift
fi

UPDATE_REQUESTED=0
while getopts ":c:p:uh" opt; do
  case "${opt}" in
    c)
      CONFIG="${OPTARG}"
      ;;
    p)
      PROFILE_ARG="${OPTARG}"
      ;;
    u)
      UPDATE_REQUESTED=1
      ;;
    h)
      usage
      exit 0
      ;;
    \?)
      echo "Option inconnue: -${OPTARG}" >&2
      usage >&2
      exit 2
      ;;
    :)
      echo "L'option -${OPTARG} requiert un argument." >&2
      usage >&2
      exit 2
      ;;
  esac
done
shift $((OPTIND - 1))

if [ -f "${CONFIG}" ]; then
  . "${CONFIG}"
fi

if [ "${APT_MODE}" = "1" ]; then
  ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ add -A \
    && "$0" commit -m "dpkg: $(date -Iseconds)" || true
  exit 0
fi

run_update() {
  if [ "$(id -u)" -ne 0 ]; then
    exec sudo -u root "$0" -u -c "${CONFIG}"
  fi
  tmpdir="$(mktemp -d /tmp/sysgit-update.XXXXXX)"
  cleanup() {
    rm -rf "${tmpdir}"
  }
  trap cleanup EXIT
  if ! "${GIT}" clone --branch "${UPDATE_BRANCH}" --depth 1 "${UPDATE_REPO}" "${tmpdir}"; then
    echo "Echec du clonage: ${UPDATE_REPO} (${UPDATE_BRANCH})" >&2
    exit 1
  fi
  if [ -f "${tmpdir}/Makefile" ]; then
    make -C "${tmpdir}" install PREFIX="${INSTALL_PREFIX}" SYSCONFDIR="${INSTALL_SYSCONFDIR}"
  elif [ -x "${tmpdir}/install.sh" ]; then
    "${tmpdir}/install.sh" "${INSTALL_PREFIX}" "${INSTALL_SYSCONFDIR}"
  else
    echo "Aucun installateur trouve dans le depot." >&2
    exit 1
  fi
  exit $?
}

if [ "${UPDATE_REQUESTED}" = "1" ]; then
  run_update
fi

if [ "${ALWAYS_ROOT}" = "1" ] || [ "${ALWAYS_ROOT}" = "true" ]; then
  uid="$(id -u)"
  if [ "${uid}" -ne "0" ]; then
    echo "This wrapper calls itself as user 'root' using sudo now:"
    exec sudo -u root "$0" "$@"
  fi
fi


ensure_logout_check() {
  if [ "${LOGOUT_CHECK}" != "1" ] && [ "${LOGOUT_CHECK}" != "true" ]; then
    return
  fi
  if [ -n "${SUDO_USER}" ]; then
    target_user="${SUDO_USER}"
    target_home="$(getent passwd "${SUDO_USER}" | cut -d: -f 6)"
  else
    target_user="$(id -un 2>/dev/null)"
    target_home="${HOME}"
  fi
  if [ -z "${target_home}" ] || [ ! -d "${target_home}" ]; then
    return
  fi
  logout_file="${target_home}/.bash_logout"
  marker_start="# >>> sysgit logout check >>>"
  marker_end="# <<< sysgit logout check <<<"
  if [ -f "${logout_file}" ] && grep -qF "${marker_start}" "${logout_file}" 2>/dev/null; then
    return
  fi
  if [ -f "${logout_file}" ] && grep -q "sysgit status" "${logout_file}" 2>/dev/null; then
    return
  fi
  if [ -f "${logout_file}" ] && [ -s "${logout_file}" ]; then
    printf '\n' >> "${logout_file}"
  else
    printf '%s\n\n' '#!/bin/bash' >> "${logout_file}"
  fi
  {
    echo "${marker_start}"
    cat <<'EOF'
if [ -x "/usr/local/bin/sysgit" ]; then
  if [ -n "$(sysgit status --porcelain 2>/dev/null)" ]; then
    echo "###############################################"
    echo "Il y a eu des modification sur le serveur :"
    echo "###############################################"
    echo
    sysgit status
    echo
    if [ -t 0 ] && [ -t 1 ]; then
      read -r -p "Vous voudriez partir sans donner les raisons de ces changement ? [O/n] "
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        sysgit commit
      fi
    fi
  fi
fi
EOF
    echo "${marker_end}"
  } >> "${logout_file}"
  if [ -n "${target_user}" ] && [ "${target_user}" != "root" ]; then
    chown "${target_user}":"${target_user}" "${logout_file}" 2>/dev/null || true
  fi
}
ensure_logout_check

# Configuration des variables d'environnement Git pour le commiteur
if [ -n "${SUDO_USER}" ]; then
  homedir="$(getent passwd "${SUDO_USER}" | cut -d: -f 6)"
  git_config_file="${homedir}/.gitconfig"
  hostname="$(hostname -f)"
  if [ -z "${GIT_COMMITTER_NAME}" ]; then
    export GIT_COMMITTER_NAME="$(git config -f "${git_config_file}" user.name)"
    export GIT_AUTHOR_NAME="$(git config -f "${git_config_file}" user.name)"
    export GIT_COMMITTER_EMAIL="$(git config -f "${git_config_file}" user.email)"
    export GIT_AUTHOR_EMAIL="$(git config -f "${git_config_file}" user.email)"
  fi
  : "${GIT_COMMITTER_EMAIL:=${SUDO_USER}@${hostname}}"
  : "${GIT_AUTHOR_EMAIL:=${SUDO_USER}@${hostname}}"
  : "${GIT_COMMITTER_NAME:=${SUDO_USER}}"
  : "${GIT_AUTHOR_NAME:=${SUDO_USER}}"
fi

# Gestion des profils multiples de commiteurs git
if [ -z "${SUDO_USER}" ] && { [ "${MULTI_GIT_COMMITTER}" = "1" ] || [ "${MULTI_GIT_COMMITTER}" = "true" ]; }; then
  uid="$(id -u)"
  if [ "${uid}" -eq "0" ]; then
    profile_file="${MULTI_GIT_COMMITTER_PROFILE:-${SYSGIT_DIR}/sysgit.profile}"
    selected_line=""
    profile_history_file="${MULTI_GIT_COMMITTER_PROFILE_HISTORY:-${SYSGIT_DIR}/sysgit.profile.history}"
    fingerprint=""
    if [ -n "${SSH_TTY}" ]; then
      fingerprint="SSH_TTY=${SSH_TTY}"
    fi
    if [ -n "${SSH_CLIENT}" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}SSH_CLIENT=${SSH_CLIENT}"
    fi
    if [ -n "${SSH_CONNECTION}" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}SSH_CONNECTION=${SSH_CONNECTION}"
    fi
    tty_path="$(tty 2>/dev/null)"
    if [ -n "${tty_path}" ] && [ "${tty_path}" != "not a tty" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}TTY=${tty_path}"
    fi
    if [ -n "${PROFILE_ARG}" ]; then
      if [ -f "${profile_file}" ]; then
        case "${PROFILE_ARG}" in
          ''|*[!0-9]*)
            selected_line="$(grep -m1 "^${PROFILE_ARG}|" "${profile_file}")"
            ;;
          *)
            selected_line="$(sed -n "${PROFILE_ARG}p" "${profile_file}")"
            ;;
        esac
      fi
      if [ -z "${selected_line}" ]; then
        echo "Profil introuvable: ${PROFILE_ARG}" >&2
        exit 1
      fi
    fi
    if [ -z "${selected_line}" ] && [ -n "${fingerprint}" ] && [ -f "${profile_history_file}" ] && [ -f "${profile_file}" ]; then
      history_profile="$(awk -F'|' -v fp="${fingerprint}" '$3 == fp {p=$2} END {print p}' "${profile_history_file}")"
      if [ -n "${history_profile}" ]; then
        selected_line="$(grep -m1 "^${history_profile}|" "${profile_file}")"
      fi
    fi
    if [ -z "${selected_line}" ]; then
      if [ ! -t 0 ] || [ ! -t 1 ]; then
        if [ -f "${profile_file}" ]; then
          selected_line="$(sed -n '1p' "${profile_file}")"
        fi
        if [ -z "${selected_line}" ]; then
          echo "Aucun profil disponible pour un contexte non-interactif." >&2
          exit 1
        fi
      else
        if [ -f "${profile_file}" ] && [ -s "${profile_file}" ]; then
          echo "Choisir un profil:"
          nl -w2 -s') ' "${profile_file}" | sed 's/|/ - /'
          echo " 0) Creer un nouveau profil"
          read -r -p "Votre choix: " choice
          if [ "${choice}" = "0" ] || [ -z "${choice}" ]; then
            selected_line=""
          else
            selected_line="$(sed -n "${choice}p" "${profile_file}")"
            if [ -z "${selected_line}" ]; then
              echo "Choix invalide." >&2
              exit 1
            fi
          fi
        fi
        if [ -z "${selected_line}" ]; then
          read -r -p "Nom: " profile_name
          read -r -p "Email: " profile_email
          if [ -z "${profile_name}" ] || [ -z "${profile_email}" ]; then
            echo "Nom ou email manquant." >&2
            exit 1
          fi
          printf '%s|%s\n' "${profile_name}" "${profile_email}" >> "${profile_file}"
          selected_line="${profile_name}|${profile_email}"
        fi
      fi
    fi
    profile_name="${selected_line%%|*}"
    profile_email="${selected_line#*|}"
    now_ts="$(date +%s)"
    printf '%s|%s|%s\n' "${now_ts}" "${profile_name}" "${fingerprint}" >> "${profile_history_file}"
    if [ -f "${profile_history_file}" ]; then
      cutoff="$((now_ts - 604800))"
      awk -F'|' -v cutoff="${cutoff}" '($1 + 0) >= cutoff' "${profile_history_file}" > "${profile_history_file}.tmp" && mv "${profile_history_file}.tmp" "${profile_history_file}"
    fi
    : "${GIT_COMMITTER_NAME:=${profile_name}}"
    : "${GIT_AUTHOR_NAME:=${profile_name}}"
    : "${GIT_COMMITTER_EMAIL:=${profile_email}}"
    : "${GIT_AUTHOR_EMAIL:=${profile_email}}"
  fi
fi

echo $GIT_AUTHOR_NAME;

if [ "${1}" = "init" ]; then
    ${GIT} init --bare "${SYSGIT_DIR}"
    ${GIT} --git-dir="${SYSGIT_DIR}" config status.showUntrackedFiles no
    read -r -p "Ajouter /etc au suivi ? [y/N] " add_etc
    if [ "${add_etc}" = "y" ] || [ "${add_etc}" = "Y" ]; then
        ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ add -f /etc
        echo "Ajoute /etc. Pour suivre d'autres repertoires: $0 add -f /chemin"
    else
        echo "Vous pouvez suivre d'autres repertoires avec: $0 add -f /chemin"
    fi
    exit $?
fi

${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ "$@"
