#!/bin/bash

# Default config values (can be overridden by /etc/sysgit.conf or -c).
GIT=/usr/bin/git
GIT_COMMIT_OPTIONS=""
SYSGIT_DIR=/var/lib/sysgit
ALWAYS_ROOT=0
LOGOUT_CHECK=0
AUTOCOMMIT=0
MULTI_GIT_COMMITTER=0
MULTI_GIT_COMMITTER_PROFILE=/var/lib/sysgit/sysgit.profile
MULTI_GIT_COMMITTER_PROFILE_HISTORY=/var/lib/sysgit/sysgit.profile.history
SYSGIT_IGNORE_FILE=/etc/sysgit.ignore
SYSGIT_IGNORE_TEMPLATE=/etc/sysgit.ignore_default
INSTALL_PREFIX=/usr/local
INSTALL_SYSCONFDIR=/etc
UPDATE_REPO=https://framagit.org/kepon/sysgit.git
UPDATE_BRANCH=main


# Load config file (system-wide defaults).
CONFIG=/etc/sysgit.conf

usage() {
  cat <<'EOF'
Usage: sysgit [-apt] [-autocommit] [-c <config>] [-p <profil>] [-u] [-h] [ignore|init|git-args...]
  -apt         Commit automatique pour les hooks APT
  -autocommit  Snapshot automatique si AUTOCOMMIT=1
  -c <config>  Chemin vers le fichier de configuration
  -p <profil>  Profil de commiteur (nom ou index)
  -u           Mettre a jour depuis le depot officiel et reinstaller
  -h           Afficher cette aide
EOF
}

ensure_ignore_file() {
  if [ -z "${SYSGIT_IGNORE_FILE}" ] || [ -f "${SYSGIT_IGNORE_FILE}" ]; then
    return
  fi
  mkdir -p "$(dirname "${SYSGIT_IGNORE_FILE}")"
  if [ -n "${SYSGIT_IGNORE_TEMPLATE}" ] && [ -f "${SYSGIT_IGNORE_TEMPLATE}" ]; then
    cp "${SYSGIT_IGNORE_TEMPLATE}" "${SYSGIT_IGNORE_FILE}"
  else
    : > "${SYSGIT_IGNORE_FILE}"
  fi
  chmod 0644 "${SYSGIT_IGNORE_FILE}" 2>/dev/null || true
}

ensure_git_excludes_config() {
  if [ -z "${SYSGIT_IGNORE_FILE}" ] || [ ! -f "${SYSGIT_IGNORE_FILE}" ]; then
    return
  fi
  if [ -d "${SYSGIT_DIR}" ]; then
    ${GIT} --git-dir="${SYSGIT_DIR}" config core.excludesfile "${SYSGIT_IGNORE_FILE}" 2>/dev/null || true
  fi
}

open_in_editor() {
  local target="${1}"
  local editor="${VISUAL:-${EDITOR}}"

  if [ -z "${editor}" ]; then
    if command -v editor >/dev/null 2>&1; then
      editor="editor"
    elif command -v sensible-editor >/dev/null 2>&1; then
      editor="sensible-editor"
    else
      editor="vi"
    fi
  fi

  local editor_cmd=(${editor})
  "${editor_cmd[@]}" "${target}"
}

# Dedicated mode for APT hooks.
APT_MODE=0
if [ "${1}" = "-apt" ]; then
  APT_MODE=1
  shift
fi

# Dedicated mode for systemd/cron autocommit snapshots.
AUTOCOMMIT_MODE=0
if [ "${1}" = "-autocommit" ]; then
  AUTOCOMMIT_MODE=1
  shift
fi

# Standard option parsing (-c/-p/-u/-h).
UPDATE_REQUESTED=0
while getopts ":c:p:uh" opt; do
  case "${opt}" in
    c)
      CONFIG="${OPTARG}"
      ;;
    p)
      PROFILE_ARG="${OPTARG}"
      ;;
    u)
      UPDATE_REQUESTED=1
      ;;
    h)
      usage
      exit 0
      ;;
    \?)
      echo "Option inconnue: -${OPTARG}" >&2
      usage >&2
      exit 2
      ;;
    :)
      echo "L'option -${OPTARG} requiert un argument." >&2
      usage >&2
      exit 2
      ;;
  esac
done
shift $((OPTIND - 1))

# Load overrides from config if present.
if [ -f "${CONFIG}" ]; then
  . "${CONFIG}"
fi

if [ "${1}" = "ignore" ]; then
  if [ -z "${SYSGIT_IGNORE_FILE}" ]; then
    echo "SYSGIT_IGNORE_FILE n'est pas configure." >&2
    exit 1
  fi
  ensure_ignore_file
  ensure_git_excludes_config
  open_in_editor "${SYSGIT_IGNORE_FILE}"
  exit $?
fi

ensure_git_excludes_config

# Handle APT post-invoke hook.
if [ "${APT_MODE}" = "1" ]; then
  ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ add -A \
    && "$0" commit -m "dpkg: $(date -Iseconds)" || true
  exit 0
fi

# Handle timed snapshots when AUTOCOMMIT is enabled.
if [ "${AUTOCOMMIT_MODE}" = "1" ]; then
  if [ "${AUTOCOMMIT}" = "0" ] || [ "${AUTOCOMMIT}" = "false" ]; then
    exit 0
  fi
  if ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ add -A; then
    if [ -n "$(${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ status --porcelain)" ]; then
      "$0" commit -m "sysgit auto: $(date -Iseconds)" || true
    fi
  fi
  exit 0
fi

# Self-update by pulling the configured repo and running its installer.
run_update() {
  if [ "$(id -u)" -ne 0 ]; then
    exec sudo -u root "$0" -u -c "${CONFIG}"
  fi
  tmpdir="$(mktemp -d /tmp/sysgit-update.XXXXXX)"
  cleanup() {
    rm -rf "${tmpdir}"
  }
  trap cleanup EXIT
  if ! "${GIT}" clone --branch "${UPDATE_BRANCH}" --depth 1 "${UPDATE_REPO}" "${tmpdir}"; then
    echo "Echec du clonage: ${UPDATE_REPO} (${UPDATE_BRANCH})" >&2
    exit 1
  fi
  if [ -f "${tmpdir}/Makefile" ]; then
    make -C "${tmpdir}" install PREFIX="${INSTALL_PREFIX}" SYSCONFDIR="${INSTALL_SYSCONFDIR}"
  elif [ -x "${tmpdir}/install.sh" ]; then
    "${tmpdir}/install.sh" "${INSTALL_PREFIX}" "${INSTALL_SYSCONFDIR}"
  else
    echo "Aucun installateur trouve dans le depot." >&2
    exit 1
  fi
  exit $?
}

if [ "${UPDATE_REQUESTED}" = "1" ]; then
  run_update
fi

# Force root execution if configured.
if [ "${ALWAYS_ROOT}" = "1" ] || [ "${ALWAYS_ROOT}" = "true" ]; then
  uid="$(id -u)"
  if [ "${uid}" -ne "0" ]; then
    echo "This wrapper calls itself as user 'root' using sudo now:"
    exec sudo -u root "$0" "$@"
  fi
fi


ensure_logout_check() {
  if [ "${LOGOUT_CHECK}" != "1" ] && [ "${LOGOUT_CHECK}" != "true" ]; then
    return
  fi
  if [ -n "${SUDO_USER}" ]; then
    target_user="${SUDO_USER}"
    target_home="$(getent passwd "${SUDO_USER}" | cut -d: -f 6)"
  else
    target_user="$(id -un 2>/dev/null)"
    target_home="${HOME}"
  fi
  if [ -z "${target_home}" ] || [ ! -d "${target_home}" ]; then
    return
  fi
  logout_file="${target_home}/.bash_logout"
  marker_start="# >>> sysgit logout check >>>"
  marker_end="# <<< sysgit logout check <<<"
  if [ -f "${logout_file}" ] && grep -qF "${marker_start}" "${logout_file}" 2>/dev/null; then
    return
  fi
  if [ -f "${logout_file}" ] && grep -q "sysgit status" "${logout_file}" 2>/dev/null; then
    return
  fi
  if [ -f "${logout_file}" ] && [ -s "${logout_file}" ]; then
    printf '\n' >> "${logout_file}"
  else
    printf '%s\n\n' '#!/bin/bash' >> "${logout_file}"
  fi
  {
    echo "${marker_start}"
    cat <<'EOF'
if [ -x "/usr/local/bin/sysgit" ]; then
  if [ -n "$(sysgit status --porcelain 2>/dev/null)" ]; then
    echo "###############################################"
    echo "Il y a eu des modification sur le serveur :"
    echo "###############################################"
    echo
    sysgit status
    echo
    if [ -t 0 ] && [ -t 1 ]; then
      read -r -p "Vous voudriez partir sans donner les raisons de ces changement ? [O/n] "
      if [[ $REPLY =~ ^[Nn]$ ]]; then
        sysgit commit
      fi
    fi
  fi
fi
EOF
    echo "${marker_end}"
  } >> "${logout_file}"
  if [ -n "${target_user}" ] && [ "${target_user}" != "root" ]; then
    chown "${target_user}":"${target_user}" "${logout_file}" 2>/dev/null || true
  fi
}
ensure_logout_check

# Set git author/committer environment based on the sudo user.
if [ -n "${SUDO_USER}" ]; then
  homedir="$(getent passwd "${SUDO_USER}" | cut -d: -f 6)"
  git_config_file="${homedir}/.gitconfig"
  hostname="$(hostname -f)"
  if [ -z "${GIT_COMMITTER_NAME}" ]; then
    export GIT_COMMITTER_NAME="$(git config -f "${git_config_file}" user.name)"
    export GIT_AUTHOR_NAME="$(git config -f "${git_config_file}" user.name)"
    export GIT_COMMITTER_EMAIL="$(git config -f "${git_config_file}" user.email)"
    export GIT_AUTHOR_EMAIL="$(git config -f "${git_config_file}" user.email)"
  fi
  : "${GIT_COMMITTER_EMAIL:=${SUDO_USER}@${hostname}}"
  : "${GIT_AUTHOR_EMAIL:=${SUDO_USER}@${hostname}}"
  : "${GIT_COMMITTER_NAME:=${SUDO_USER}}"
  : "${GIT_AUTHOR_NAME:=${SUDO_USER}}"
fi

# Optional multiple committer profiles (root, interactive).
if [ -z "${SUDO_USER}" ] && { [ "${MULTI_GIT_COMMITTER}" = "1" ] || [ "${MULTI_GIT_COMMITTER}" = "true" ]; }; then
  uid="$(id -u)"
  if [ "${uid}" -eq "0" ]; then
    profile_file="${MULTI_GIT_COMMITTER_PROFILE:-${SYSGIT_DIR}/sysgit.profile}"
    selected_line=""
    selection_source=""
    profile_history_file="${MULTI_GIT_COMMITTER_PROFILE_HISTORY:-${SYSGIT_DIR}/sysgit.profile.history}"
    fingerprint=""
    if [ -n "${SSH_TTY}" ]; then
      fingerprint="SSH_TTY=${SSH_TTY}"
    fi
    if [ -n "${SSH_CLIENT}" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}SSH_CLIENT=${SSH_CLIENT}"
    fi
    if [ -n "${SSH_CONNECTION}" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}SSH_CONNECTION=${SSH_CONNECTION}"
    fi
    tty_path="$(tty 2>/dev/null)"
    if [ -n "${tty_path}" ] && [ "${tty_path}" != "not a tty" ]; then
      if [ -n "${fingerprint}" ]; then
        fingerprint="${fingerprint},"
      fi
      fingerprint="${fingerprint}TTY=${tty_path}"
    fi
    if [ -n "${PROFILE_ARG}" ]; then
      if [ -f "${profile_file}" ]; then
        case "${PROFILE_ARG}" in
          ''|*[!0-9]*)
            selected_line="$(grep -m1 "^${PROFILE_ARG}|" "${profile_file}")"
            ;;
          *)
            selected_line="$(sed -n "${PROFILE_ARG}p" "${profile_file}")"
            ;;
        esac
      fi
      if [ -z "${selected_line}" ]; then
        create_profile=1
        profile_name=""
        profile_email=""
        case "${PROFILE_ARG}" in
          *'|'*)
            profile_name="${PROFILE_ARG%%|*}"
            profile_email="${PROFILE_ARG#*|}"
            ;;
          *:*)
            profile_name="${PROFILE_ARG%%:*}"
            profile_email="${PROFILE_ARG#*:}"
            ;;
          *)
            profile_name="${PROFILE_ARG}"
            ;;
        esac
        if [ -t 0 ] && [ -t 1 ]; then
          read -r -p "Profil introuvable: ${PROFILE_ARG}. Creer le profil ${profile_name} ? [o/N] " create_choice
          if [[ ! "${create_choice}" =~ ^[Oo]$ ]]; then
            create_profile=0
          fi
          if [ "${create_profile}" = "1" ]; then
            if [ -z "${profile_name}" ]; then
              read -r -p "Nom: " profile_name
            fi
            if [ -z "${profile_email}" ]; then
              read -r -p "Entrer son e-mail: " profile_email
            fi
          fi
        fi
        if [ "${create_profile}" = "1" ]; then
          if [ -z "${profile_name}" ] || [ -z "${profile_email}" ]; then
            echo "Nom ou email manquant." >&2
            exit 1
          fi
          mkdir -p "$(dirname "${profile_file}")"
          printf '%s|%s\n' "${profile_name}" "${profile_email}" >> "${profile_file}"
          selected_line="${profile_name}|${profile_email}"
        else
          PROFILE_ARG=""
        fi
      fi
      if [ -n "${selected_line}" ]; then
        selection_source="forced"
      fi
    fi
    if [ -z "${selected_line}" ] && [ -n "${fingerprint}" ] && [ -f "${profile_history_file}" ] && [ -f "${profile_file}" ]; then
      history_profile="$(awk -F'|' -v fp="${fingerprint}" '$3 == fp {p=$2} END {print p}' "${profile_history_file}")"
      if [ -n "${history_profile}" ]; then
        selected_line="$(grep -m1 "^${history_profile}|" "${profile_file}")"
        if [ -n "${selected_line}" ]; then
          selection_source="history"
        fi
      fi
    fi
    if [ -z "${selected_line}" ]; then
      if [ ! -t 0 ] || [ ! -t 1 ]; then
        if [ -f "${profile_file}" ]; then
          selected_line="$(sed -n '1p' "${profile_file}")"
        fi
        if [ -z "${selected_line}" ]; then
          echo "Aucun profil disponible pour un contexte non-interactif." >&2
          exit 1
        fi
      else
        if [ -f "${profile_file}" ] && [ -s "${profile_file}" ]; then
          echo "Choisir un profil:"
          nl -w2 -s') ' "${profile_file}" | sed 's/|/ - /'
          echo " 0) Creer un nouveau profil"
          read -r -p "Votre choix: " choice
          if [ "${choice}" = "0" ] || [ -z "${choice}" ]; then
            selected_line=""
          else
            selected_line="$(sed -n "${choice}p" "${profile_file}")"
            if [ -z "${selected_line}" ]; then
              echo "Choix invalide." >&2
              exit 1
            fi
          fi
        fi
        if [ -z "${selected_line}" ]; then
          read -r -p "Nom: " profile_name
          read -r -p "Email: " profile_email
          if [ -z "${profile_name}" ] || [ -z "${profile_email}" ]; then
            echo "Nom ou email manquant." >&2
            exit 1
          fi
          printf '%s|%s\n' "${profile_name}" "${profile_email}" >> "${profile_file}"
          selected_line="${profile_name}|${profile_email}"
        fi
      fi
    fi
    profile_name="${selected_line%%|*}"
    profile_email="${selected_line#*|}"
    now_ts="$(date +%s)"
    printf '%s|%s|%s\n' "${now_ts}" "${profile_name}" "${fingerprint}" >> "${profile_history_file}"
    if [ -f "${profile_history_file}" ]; then
      cutoff="$((now_ts - 604800))"
      awk -F'|' -v cutoff="${cutoff}" '($1 + 0) >= cutoff' "${profile_history_file}" > "${profile_history_file}.tmp" && mv "${profile_history_file}.tmp" "${profile_history_file}"
    fi
    : "${GIT_COMMITTER_NAME:=${profile_name}}"
    : "${GIT_AUTHOR_NAME:=${profile_name}}"
    : "${GIT_COMMITTER_EMAIL:=${profile_email}}"
    : "${GIT_AUTHOR_EMAIL:=${profile_email}}"
    if [ "${selection_source}" = "history" ] && [ -t 1 ]; then
      color_start=""
      color_end=""
      if command -v tput >/dev/null 2>&1; then
        color_start="$(tput setaf 6)"
        color_end="$(tput sgr0)"
      else
        color_start=$'\033[36m'
        color_end=$'\033[0m'
      fi
      printf '%sEn tant que%s %s <%s> (preciser -p pour changer)\n' \
        "${color_start}" "${color_end}" "${profile_name}" "${profile_email}"
    fi
  fi
fi

# Initialize the bare repository and optionally add /etc.
if [ "${1}" = "init" ]; then
    ${GIT} init --bare "${SYSGIT_DIR}"
    ${GIT} --git-dir="${SYSGIT_DIR}" config status.showUntrackedFiles no
    ensure_ignore_file
    ensure_git_excludes_config
    read -r -p "Ajouter /etc au suivi ? [y/N] " add_etc
    if [ "${add_etc}" = "y" ] || [ "${add_etc}" = "Y" ]; then
        ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ add -f /etc
        echo "Ajoute /etc. Pour suivre d'autres repertoires: $0 add -f /chemin"
    else
        echo "Vous pouvez suivre d'autres repertoires avec: $0 add -f /chemin"
    fi
    exit $?
fi

if [ "${1}" = "commit" ]; then
    ${GIT} ${GIT_COMMIT_OPTIONS} --git-dir="${SYSGIT_DIR}" --work-tree=/ "$@"
else
    # Delegate all other commands to git with the correct git-dir/work-tree.
    ${GIT} --git-dir="${SYSGIT_DIR}" --work-tree=/ "$@"
fi
